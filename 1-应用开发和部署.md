## 应用开发和部署

### 使用唯一性标识给镜像打标签

当生成容器镜像时，应当使用唯一性标识来给容器镜像打标签，唯一标识可以更好的标记当次生成的镜像，避免出现多个同名标签但不同的版本镜像被使用的情况。例如多次部署都使用了latest标签的镜像，可能因为拉取和缓存策略导致不同节点使用了不同版本的镜像，从而导致功能上的不一致，在这种情况下，并不能很方便的判断出某个节点部署的是哪一个版本。

唯一标识最好有一定的含义，不仅可以用来区分产物，还可以获取到本次构建的关键信息。比如git提交哈希等关联性比较强的标识。虽然时间戳也是一个唯一性比较强的标识，但是关联性相对较差，如果长度不足，也有一定的几率产生碰撞。可以考虑使用组合型标签，比如使用时间戳，build号，版本号等根据自己的需求来组合生成唯一标识，这样的标签本身就包含了很丰富的信息。

我们不建议单纯使用pipeline的build序号来作为镜像的标签，如果需要更换CI工具或者重建pipeline时，这个序号将会被重置而可能产生重复，除非在构建脚本中加入偏移量。而且不同的CI工具获取这个序号的方法也有所不同，对于迁移并不友好。虽然它的可追溯性看起来较好，但是单纯的Build序号和代码之间并没有直接的关联。

如果不是需要对外公开发布的镜像，并不建议对同一镜像打上多个不同标签。因为绝大部分的情况下，我们只会选用其中一个的标签在所有的地方使用，多个标签的实际意义并不会很大。


**唯一性标识的优点：**

1. 可以准确对应的到源代码具体版本，在溯源时可以对应到特定的提交而不是可能存在的多个提交。

2. 不需要使用SHA256等额外的信息来区分同一标签的不同版本。

**可能存在的缺点：**

1. 一些类型的唯一性标识可读性不是很高，比如git提交哈希。

2. 一些类型的标识受时间影响，不能使用同一命令获得一致结果，需要使用其他的方式来传递给后续阶段，比如时间戳。



**如何实施：**

```
GIT_HASH=$(git rev-parse HEAD)

docker build --rm -t "myapp:${GIT_HASH}" .
```

### 牲口模式

将需要大量、精心工作来维护的具有特定属性的服务实例（宠物模式），转变为可以被随时销毁和被替换的服务实例组（牲口模式），从而将更多资源和精力投入到更有价值的地方。配合自动化的基础设施，使服务实例以更快的速度演进，也使业务具备更多的弹性去应对市场变化。

为大家所熟知的“无状态”应用，是“牲口模式”的一种实现方式。“牲口模式”不等于“无状态”。

**宠物模式的弊端：**
1. 需要单独管理每一个服务实例，可能是手动安装、调试。
2. 服务实例只能垂直扩展（Scale-Up），昂贵且容易遇到瓶颈。
3. 应用部署笨重，难以自由地升级或者回滚应用，从而阻碍业务频繁变更。
4. 难以及时给服务实例打补丁、升级系统，从而承担不必要的安全风险。
5. 难以避免故障带来的服务失效和可能存在的数据损失的风险。

**牲口模式的收益：**
1. 支持自动故障切换。配合自动化基础设施，无需单独管理每个服务实例，节约管理成本和团队精力。
2. 支持自动水平伸缩（Scale-Out），配合自动化基础设施，从容应对业务峰谷，节约业务成本。
3. 支持随时被销毁或被替换，可以在不影响服务稳定性的前提下部署应用、进行系统升级或者打补丁。 

**如何实施：**
* “无状态”应用
1. API请求之间完全隔离，完成业务所需的数据均由客户端发送的请求提供。
2. 使用客户端Cookie、cache取代服务器端Session。对于一些敏感的临时数据，服务器端可以加密后交由客户端存储，在下个API请求时发回服务器解密使用。
3. 通过锁或者幂等性设计，使得应用能正确、快速、自动地解决对同一份数据的竞争而导致的流程异常、数据不一致等问题。例如，定时任务批量读取数据。

### 让业务升级向前兼容

根据Wikipedia的说法，向前兼容指低版本的系统、程序或技术能优雅处理（例如：忽略其不理解的部分）高版本的系统、程序或技术。向前兼容技术的目标是让旧设备能够识别为新设备生成的数据。

简单的说就是旧版本的系统可以接受新版本的数据，是旧版本对新版本的兼容。

在做业务升级时候，设计你的业务具有向前兼容的能力，以应对升级失败时某一功能模块或者依赖无法随之回滚的风险。比如说在有数据库字段变化的升级中，在正式对数据库做变动之前，基于旧的业务流程做代码层面更新，使其可以兼容数据库将要发生的改动并加以部署。在数据库升级完成之后，如果新的业务流程上线后不幸出现重大的问题等情况需要回滚时，回滚之后的代码仍然可以兼容数据库的变化，而不用对数据库也进行回滚。

**好处：**
1. 支持安全、快速回滚：保持向前兼容意味着，当新版本出现问题需要回滚的时候，可以安全快速当回滚到旧的版本。哪怕整个系统有‘不可回滚’的部分，那也只是部分‘不可回滚’，不必考虑其他费力措施解决完全不可回滚的问题。
2. 简化发布，持续升级：业务升级向前兼容意味着升级不再令人望而生畏，而是可以‘轻松写意’的。虽然持续升级是一个系统的工程实践，不单单指升级版本，还包括为了预防升级版本给质量带来风险而采取的其他措施，比如自动化测试的持续构建，持续集成流水线的构建等，但是向前兼容使得部署可以安全，回滚可以快速，服务一直在线，收益远大于问题。

**影响：**
1. 设计成本：要做到兼容未来的变化。这听起来就很难。一开始很难获知所有用例、极端案例和业务理解。回顾过去并说这是一个错误的决定很容易，今天做出明天不会后悔的决定要困难得多。
2. 开发成本：需要在代码中增加复杂性，这些复杂性可能并不是实现现实业务逻辑必须的，继而给现有系统功能的可靠性带来间接影响。

**如何实施：**
1. select语句只获取需要的字段，禁止使用select * from语句，有效防止新增字段对应用逻辑的影响，还能减少对性能的影响。
2. 只新增接口，对现有接口不能做任何修改，同时可感知到的默认行为都要保持不变。
3. 如需修改接口，通过在接口上增加版本号。
4. 数据库表结构变更通过新增字段实现。
5. 给新增字段提供默认值。比如shell脚本新增一个输入变量，提供默认值。脚本类似如下获取输入：
NEW_VARIABLE=${NEW_VARIABLE:-DEFAULT_VALUE}
6. APP提供强制更新功能。



