## 应用开发和部署

### 使用唯一性标识给镜像打标签

当生成容器镜像时，应当使用唯一性标识来给容器镜像打标签，唯一标识可以更好的标记当次生成的镜像，避免出现多个同名标签但不同的版本镜像被使用的情况。例如多次部署都使用了latest标签的镜像，可能因为拉取和缓存策略导致不同节点使用了不同版本的镜像，从而导致功能上的不一致，在这种情况下，并不能很方便的判断出某个节点部署的是哪一个版本。

唯一标识最好有一定的含义，不仅可以用来区分产物，还可以获取到本次构建的关键信息。比如git提交哈希等关联性比较强的标识。虽然时间戳也是一个唯一性比较强的标识，但是关联性相对较差，如果长度不足，也有一定的几率产生碰撞。可以考虑使用组合型标签，比如使用时间戳，build号，版本号等根据自己的需求来组合生成唯一标识，这样的标签本身就包含了很丰富的信息。

我们不建议单纯使用pipeline的build序号来作为镜像的标签，如果需要更换CI工具或者重建pipeline时，这个序号将会被重置而可能产生重复，除非在构建脚本中加入偏移量。而且不同的CI工具获取这个序号的方法也有所不同，对于迁移并不友好。虽然它的可追溯性看起来较好，但是单纯的Build序号和代码之间并没有直接的关联。

如果不是需要对外公开发布的镜像，并不建议对同一镜像打上多个不同标签。因为绝大部分的情况下，我们只会选用其中一个的标签在所有的地方使用，多个标签的实际意义并不会很大。


**唯一性标识的优点：**

1. 可以准确对应的到源代码具体版本，在溯源时可以对应到特定的提交而不是可能存在的多个提交。

2. 不需要使用SHA256等额外的信息来区分同一标签的不同版本。

**可能存在的缺点：**

1. 一些类型的唯一性标识可读性不是很高，比如git提交哈希。

2. 一些类型的标识受时间影响，不能使用同一命令获得一致结果，需要使用其他的方式来传递给后续阶段，比如时间戳。



**如何实施：**

```
GIT_HASH=$(git rev-parse HEAD)

docker build --rm -t "myapp:${GIT_HASH}" .
```

### 牲口模式

将需要大量、精心工作来维护的具有特定属性的服务实例（宠物模式），转变为可以被随时销毁和被替换的服务实例组（牲口模式），从而将更多资源和精力投入到更有价值的地方。配合自动化的基础设施，使服务实例以更快的速度演进，也使业务具备更多的弹性去应对市场变化。

为大家所熟知的“无状态”应用，是“牲口模式”的一种实现方式。“牲口模式”不等于“无状态”。

**宠物模式的弊端：**
1. 需要单独管理每一个服务实例，可能是手动安装、调试。
2. 服务实例只能垂直扩展（Scale-Up），昂贵且容易遇到瓶颈。
3. 应用部署笨重，难以自由地升级或者回滚应用，从而阻碍业务频繁变更。
4. 难以及时给服务实例打补丁、升级系统，从而承担不必要的安全风险。
5. 难以避免故障带来的服务失效和可能存在的数据损失的风险。

**牲口模式的收益：**
1. 支持自动故障切换。配合自动化基础设施，无需单独管理每个服务实例，节约管理成本和团队精力。
2. 支持自动水平伸缩（Scale-Out），配合自动化基础设施，从容应对业务峰谷，节约业务成本。
3. 支持随时被销毁或被替换，可以在不影响服务稳定性的前提下部署应用、进行系统升级或者打补丁。 

**如何实施：**
* “无状态”应用
1. API请求之间完全隔离，完成业务所需的数据均由客户端发送的请求提供。
2. 使用客户端Cookie、cache取代服务器端Session。对于一些敏感的临时数据，服务器端可以加密后交由客户端存储，在下个API请求时发回服务器解密使用。
3. 通过锁或者幂等性设计，使得应用能正确、快速、自动地解决对同一份数据的竞争而导致的流程异常、数据不一致等问题。例如，定时任务批量读取数据。

### 让业务升级向后兼容

向后兼容(Backward Compatibility): 在计算机中指在一个程序、库或硬件更新到较新版本后，用旧版本程序创建的文档或系统仍能被正常操作或使用（包括输入数据）、在旧版本库的基础上开发的程序仍能正常编译运行，或较旧版的硬件仍可在新版使用的情况。 –- from Wikipedia

简单的说就是新的版本的软／硬件可以使用老版本的软／硬件产生的数据。在软件兼容性方面，软件应该能够与旧版本顺利运行，没有任何困难或不一致。

在做业务升级时候，设计你的业务具有向后兼容的能力，当升级时可保持新旧版本同时运行，快速的验证新版本；当升级失败时，业务能够快速回滚，将影响降低在最小的限度。

与向后兼容相对应的是向前兼容(Forward Compatibility)。在做业务升级时候，设计你的业务具有向前兼容的能力，以应对升级失败时某一功能模块或者依赖无法随之回滚的风险。比如说在有数据库字段变化的升级中，在正式对数据库做变动之前，基于旧的业务流程做代码层面更新，使其可以兼容数据库将要发生的改动并加以部署。在数据库升级完成之后，如果新的业务流程上线后不幸出现重大的问题等情况需要回滚时，回滚之后的代码仍然可以兼容数据库的变化，而不用对数据库也进行回滚。

如果更改既向前兼容又向后兼容，则称为完全兼容。(If a change is both forward and backward compatible, then it is called fully compatible.)

*注意：限于篇幅，此处仅讨论向后兼容。*

**好处：**
1. 支持安全、快速回滚：保持向后兼容意味着运行环境可以同时跑多个版本的程序，当新版本出现问题需要回滚的时候，可以安全快速的回滚到旧的版本。

2. 支持零宕机部署：当业务升级的时候，一种更新策略是滚动更新(RollingUpdate), 即先更新业务的一部分副本，逐步替换旧的副本，最终业务的所有副本都更新为最新的版本。如果业务不支持向后兼容，意味着滚动更新的时候会有服务不可用时间，只有当业务的副本全部更新完毕后才能正式对外提供服务。否则在滚动更新期间，多版本并行对外提供服务会出现不可预知的各种兼容性问题。

3. 支持金丝雀部署：业务升级向后兼容意味着金丝雀部署成为可能。可以在运行环境里面同时跑多个版本的程序，并利用流量控制策略更新新旧版本流量百分比。比如一开始新版本接受小部分对流量，测试验证无问题则继续扩大新版本流量百分比，最终完全接管旧版本的流量。当新版本出现问题也可快速回滚，影响的也是这一小部分的流量。

4. 简化发布，持续升级：业务升级向后兼容意味着升级不再令人望而生畏，而是可以‘轻松写意’的。虽然持续升级是一个系统 的工程实践，不单单指升级版本，还包括为了预防升级版本给质量带来风险而采取的其他措施，比如自动化测试的持续构建，持续集成流水线的构建等，但是向后兼容使得部署可以安全，回滚可以快速，服务一直在线，最小化的基础设施保持多版本在线和流量控制，收益远大于问题。

5. 保持向后兼容可以屏蔽使用者对于变化的感知，维持现有功能的稳定性，降低引入新版本的成本， 减少对现有系统功能的影响。

6. 保留较旧的软件和硬件： 向后兼容性有助于公司确保其较旧的硬件和软件始终可用。当公司升级或更换新产品时，这可能会丢失。

7. 具有向后兼容性意味着客户不会被迫购买新的硬件或软件，而是可以选择升级。

**影响：**

1. 开发成本：需要在代码中增加复杂性，这些复杂性可能并不是实现现实业务逻辑必须的，继而给现有系统功能的可靠性带来间接影响。

2. 维护成本：如果需要硬件来支持遗留系统，则向后兼容的相关成本是更大的材料清单。

3. 产品复杂性增加，可能导致上市时间延长、技术障碍和创新放缓。

**如何实施：**

1. 只新增接口，对现有接口不能做任何修改，同时可感知到的默认行为都要保持不变。

2. 如需修改接口，通过在接口上增加版本号。

3. 数据库表结构变更通过新增字段实现。

4. 给新增字段提供默认值。比如shell脚本新增一个输入变量，提供默认值。脚本类似如下获取输入：
NEW_VARIABLE=${NEW_VARIABLE:-DEFAULT_VALUE}
那么对于客户端（之前调用此shell脚本的程序）来说，服务端（shell脚本）的更新它自身无需做任何适配性修改。

5. APP提供强制更新功能。
